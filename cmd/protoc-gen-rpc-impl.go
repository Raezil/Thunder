package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_server.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-rpc-impl. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Write imports
	g.P("import (")
	g.P(`    "context"`)
	g.P(")")
	g.P()

	// Generate implementation struct and methods for each service
	for _, service := range file.Services {
		generateServiceImplementation(g, service)
	}
}

func generateServiceImplementation(g *protogen.GeneratedFile, service *protogen.Service) {
	structName := service.GoName + "ServiceServer"

	// Generate struct
	g.P("type ", structName, " struct {")
	g.P("    Unimplemented", service.GoName, "Server")
	g.P("}")
	g.P()

	// Constructor
	g.P("func New", structName, "() *", structName, " {")
	g.P("    return &", structName, "{}")
	g.P("}")
	g.P()

	// Generate methods
	for _, method := range service.Methods {
		generateMethodImplementation(g, method, structName)
	}
}

func generateMethodImplementation(g *protogen.GeneratedFile, method *protogen.Method, structName string) {
	methodName := method.GoName
	inputType := method.Input.GoIdent.GoName
	outputType := method.Output.GoIdent.GoName

	signature := fmt.Sprintf("func (s *%s) %s(ctx context.Context, req *%s) (*%s, error)",
		structName, methodName, inputType, outputType)

	g.P(signature, " {")
	g.P("    // TODO: Implement ", methodName)
	g.P("    return &", outputType, "{}, nil")
	g.P("}")
	g.P()
}
